package Common

import chisel3._
object ISA
{

    val PC_SIZE = 32
    val ADDR_SIZE = 32
    val INSTR_SIZE = 32
    val XLEN = 32
    val EXCEPTION_ADDR = "hBFC00380".U(ADDR_SIZE.W)

    val ALU_WIDTH = 5 //ALU控制信号宽度
    val RegNUM_WIDTH = 6  //寄存器编号宽度
    val MDU_CNT_WIDTH = 8
    val MDU_CYCLE = 5.U(MDU_CNT_WIDTH.W)
}


import Common.ISA._
object ALUOP
{
    val ALU_ADD    = 0.U(ALU_WIDTH.W)
    val ALU_SUB    = 1.U(ALU_WIDTH.W)
    val ALU_AND    = 2.U(ALU_WIDTH.W)
    val ALU_OR     = 3.U(ALU_WIDTH.W)
    val ALU_XOR    = 4.U(ALU_WIDTH.W)
    val ALU_NOR    = 5.U(ALU_WIDTH.W)
    val ALU_SLL    = 6.U(ALU_WIDTH.W)
    val ALU_SRL    = 7.U(ALU_WIDTH.W)
    val ALU_SRA    = 8.U(ALU_WIDTH.W)
    val ALU_SLT    = 9.U(ALU_WIDTH.W)
    val ALU_SLTU   = 10.U(ALU_WIDTH.W)
    val ALU_CMP_EQ = 11.U(ALU_WIDTH.W)
    val ALU_CMP_NE = 12.U(ALU_WIDTH.W)
    val ALU_CMP_GE = 13.U(ALU_WIDTH.W)
    val ALU_CMP_GT = 14.U(ALU_WIDTH.W)
    val ALU_ADDU   = 15.U(ALU_WIDTH.W)
    val ALU_SUBU   = 16.U(ALU_WIDTH.W)
    val ALU_COPY1  = 17.U(ALU_WIDTH.W) // DataA choose
    val ALU_COPY2  = 18.U(ALU_WIDTH.W) // DataB choose
    val ALU_LUI    = 19.U(ALU_WIDTH.W)
}

object MDUOP
{
    val MDU_MULT   = 20.U(ALU_WIDTH.W) // signed mul
    val MDU_MULTU  = 21.U(ALU_WIDTH.W) // unsigned mul
    val MDU_DIVT   = 22.U(ALU_WIDTH.W) // signed div
    val MDU_DIVTU  = 23.U(ALU_WIDTH.W) // unsigned div
}


object DecodeSignal
{
    // MemWrite
    val MemWrite_Disable = false.B
    val MemWrite_Enable  = true.B

    // RegWrite
    val RegWrite_Disable = false.B
    val RegWrite_Enable  = true.B


    // MemtoReg  写入的数据来自哪里
    val From_ALU = 0.U(1.W) // 来自ALU
    val From_MEM = 1.U(1.W) // 来自内存

    // MEMOP
    val MEMOP_WIDTH = 3
    val Ubyte   = 0.U(MEMOP_WIDTH.W) //单字节0拓展 (Default)
    val Sbyte   = 1.U(MEMOP_WIDTH.W) //单字节带符号拓展
    val Udbyte  = 2.U(MEMOP_WIDTH.W) //双字节0拓展
    val Sdbyte  = 3.U(MEMOP_WIDTH.W) //双字节带符号拓展
    val word    = 4.U(MEMOP_WIDTH.W) //一字长(四字节)

    // ALUAsrc
    val ALUAsrc_WIDTH = 2
    val From_Ra_Asrc  = 0.U(ALUAsrc_WIDTH.W)   //来自寄存器r1
    val From_PC4_Asrc = 1.U(ALUAsrc_WIDTH.W)   //来自PC4
    val From_PC8_Asrc = 2.U(ALUAsrc_WIDTH.W)   //来自PC8
    val From_NO_Asrc  = 3.U(ALUAsrc_WIDTH.W)   //不需要操作数a


    // ALUBsrc
    val ALUBsrc_WIDTH = 2
    val From_Imm_Bsrc = 0.U(ALUBsrc_WIDTH.W)   //来自拓展后的立即数
    val From_Rb_Bsrc  = 1.U(ALUBsrc_WIDTH.W)   //来自r2寄存器
    val From_NO_Bsrc  = 2.U(ALUBsrc_WIDTH.W)   //不需要操作数b

    // EXTCtrl
    val EXTCtrl_WIDTH = 3
    val Zero_Expansion = 0.U(EXTCtrl_WIDTH.W)  //imm零拓展
    val Symb_Expansion = 1.U(EXTCtrl_WIDTH.W)  //imm符号拓展
    val Addr_Expansion = 2.U(EXTCtrl_WIDTH.W)  //imm左移两位并符号拓展
    val Shif_Expansion = 3.U(EXTCtrl_WIDTH.W)  //imm左移16位
    val SA_Z_Expansion = 4.U(EXTCtrl_WIDTH.W)  //sa零拓展

    // 要考虑的例外信号
    val Exception_WIDTH = 4
    val Exception_No         = 0.U(Exception_WIDTH.W) // 无需考虑例外
    val Exception_OverFlow   = 1.U(Exception_WIDTH.W) // 考虑整数溢出
    val Exception_ZeroCheck1 = 2.U(Exception_WIDTH.W) // 考虑地址最低一位不为0
    val Exception_ZeroCheck2 = 3.U(Exception_WIDTH.W) // 考虑地址最低两位不为0
    val Exception_BreakPoint = 4.U(Exception_WIDTH.W) // 考虑断点
    val Exception_ERET       = 5.U(Exception_WIDTH.W) // 标明这是异常返回指令
    val Exception_SystemCall = 6.U(Exception_WIDTH.W) // 考虑系统调用
    val Exception_Error      = 7.U(Exception_WIDTH.W) // 这是一个特殊的例外 --> 出现这个例外表明指令无法被译码
    val Exception_InstrAddr  = 8.U(Exception_WIDTH.W) // 指令地址错误
    val Exception_Soft       = 9.U(Exception_WIDTH.W) // 软件中断

    // 指令的种类
    val InstrType_WIDTH = 3
    val NoType     = 0.U(InstrType_WIDTH.W)
    val Load       = 1.U(InstrType_WIDTH.W)
    val Store      = 2.U(InstrType_WIDTH.W)
    val MulDiv     = 3.U(InstrType_WIDTH.W)
    val EretType   = 4.U(InstrType_WIDTH.W)
    val SystemCall = 5.U(InstrType_WIDTH.W)
    val BreakPoint = 6.U(InstrType_WIDTH.W)
}


// 寄存器通用命名
object RegistersName
{
    // 通用寄存器为0~31
    val r0  = 0.U(RegNUM_WIDTH.W)  //对应0号寄存器
    val zero = 0.U(RegNUM_WIDTH.W)
    val at = 1.U(RegNUM_WIDTH.W)
    val v0 = 2.U(RegNUM_WIDTH.W)
    val v1 = 3.U(RegNUM_WIDTH.W)
    val a0 = 4.U(RegNUM_WIDTH.W)
    val a1 = 5.U(RegNUM_WIDTH.W)
    val a2 = 6.U(RegNUM_WIDTH.W)
    val a3 = 7.U(RegNUM_WIDTH.W)
    val t0 = 8.U(RegNUM_WIDTH.W)
    val t1 = 9.U(RegNUM_WIDTH.W)
    val t2 = 10.U(RegNUM_WIDTH.W)
    val t3 = 11.U(RegNUM_WIDTH.W)
    val t4 = 12.U(RegNUM_WIDTH.W)
    val t5 = 13.U(RegNUM_WIDTH.W)
    val t6 = 14.U(RegNUM_WIDTH.W)
    val t7 = 15.U(RegNUM_WIDTH.W)

    val s0 = 16.U(RegNUM_WIDTH.W)
    val s1 = 17.U(RegNUM_WIDTH.W)
    val s2 = 18.U(RegNUM_WIDTH.W)
    val s3 = 19.U(RegNUM_WIDTH.W)
    val s4 = 20.U(RegNUM_WIDTH.W)
    val s5 = 21.U(RegNUM_WIDTH.W)
    val s6 = 22.U(RegNUM_WIDTH.W)
    val s7 = 23.U(RegNUM_WIDTH.W)
    val t8 = 24.U(RegNUM_WIDTH.W)
    val t9 = 25.U(RegNUM_WIDTH.W)
    val k0 = 26.U(RegNUM_WIDTH.W)
    val k1 = 27.U(RegNUM_WIDTH.W)
    val gp = 28.U(RegNUM_WIDTH.W)
    val sp = 29.U(RegNUM_WIDTH.W)
    val s8 = 30.U(RegNUM_WIDTH.W)
    val r31 = 31.U(RegNUM_WIDTH.W)  //对应31号寄存器

    // 乘除法寄存器
    val HI = 32.U(RegNUM_WIDTH.W)
    val LO = 33.U(RegNUM_WIDTH.W)

    // CP0寄存器
    val BadVAddr = 34.U(RegNUM_WIDTH.W)
    val Count    = 35.U(RegNUM_WIDTH.W)
    val Status   = 36.U(RegNUM_WIDTH.W)
    val Cause    = 37.U(RegNUM_WIDTH.W)
    val EPC      = 38.U(RegNUM_WIDTH.W)
}


import chisel3.util.BitPat
object Instrcutions
{
    def NOP     = BitPat("b00000000000000000000000000000000")
    def ADD     = BitPat("b000000???????????????00000100000")
    def ADDI    = BitPat("b001000??????????????????????????")
    def ADDU    = BitPat("b000000???????????????00000100001")
    def ADDIU   = BitPat("b001001??????????????????????????")
    def SUB     = BitPat("b000000???????????????00000100010")
    def SUBU    = BitPat("b000000???????????????00000100011")
    def SLT     = BitPat("b000000???????????????00000101010")
    def SLTI    = BitPat("b001010??????????????????????????")
    def SLTU    = BitPat("b000000???????????????00000101011")
    def SLTIU   = BitPat("b001011??????????????????????????")
    def DIV     = BitPat("b000000??????????0000000000011010")
    def DIVU    = BitPat("b000000??????????0000000000011011")
    def MULT    = BitPat("b000000??????????0000000000011000")
    def MULTU   = BitPat("b000000??????????0000000000011001")
    def AND     = BitPat("b000000???????????????00000100100")
    def ANDI    = BitPat("b001100??????????????????????????")
    def LUI     = BitPat("b00111100000?????????????????????")
    def NOR     = BitPat("b000000???????????????00000100111")
    def OR      = BitPat("b000000???????????????00000100101")
    def ORI     = BitPat("b001101??????????????????????????")
    def XOR     = BitPat("b000000???????????????00000100110")
    def XORI    = BitPat("b001110??????????????????????????")
    def SLLV    = BitPat("b000000???????????????00000000100")
    def SLL     = BitPat("b00000000000???????????????000000")
    def SRAV    = BitPat("b000000???????????????00000000111")
    def SRA     = BitPat("b00000000000???????????????000011")
    def SRLV    = BitPat("b000000???????????????00000000110")
    def SRL     = BitPat("b00000000000???????????????000010")
    def BEQ     = BitPat("b000100??????????????????????????")
    def BNE     = BitPat("b000101??????????????????????????")
    def BGEZ    = BitPat("b000001?????00001????????????????")
    def BGTZ    = BitPat("b000111?????00000????????????????")
    def BLEZ    = BitPat("b000110?????00000????????????????")
    def BLTZ    = BitPat("b000001?????00000????????????????")
    def BGEZAL  = BitPat("b000001?????10001????????????????")
    def BLTZAL  = BitPat("b000001?????10000????????????????")
    def J       = BitPat("b000010??????????????????????????")
    def JAL     = BitPat("b000011??????????????????????????")
    def JR      = BitPat("b000000?????000000000000000001000")
    def JALR    = BitPat("b000000?????00000?????00000001001")
    def MFHI    = BitPat("b0000000000000000?????00000010000")
    def MFLO    = BitPat("b0000000000000000?????00000010010")
    def MTHI    = BitPat("b000000?????000000000000000010001")
    def MTLO    = BitPat("b000000?????000000000000000010011")
    def BREAK   = BitPat("b000000????????????????????001101")
    def SYSCALL = BitPat("b000000????????????????????001100")
    def LB      = BitPat("b100000??????????????????????????")
    def LBU     = BitPat("b100100??????????????????????????")
    def LH      = BitPat("b100001??????????????????????????")
    def LHU     = BitPat("b100101??????????????????????????")
    def LW      = BitPat("b100011??????????????????????????")
    def SB      = BitPat("b101000??????????????????????????")
    def SH      = BitPat("b101001??????????????????????????")
    def SW      = BitPat("b101011??????????????????????????")
    def ERET    = BitPat("b01000010000000000000000000011000")
    def MFC0    = BitPat("b01000000000??????????00000000???")
    def MTC0    = BitPat("b01000000100??????????00000000???")
}

object MEMWRITEDECODE
{
    def oneByte0 = BitPat("b00000")
    def oneByte1 = BitPat("b01000")
    def oneByte2 = BitPat("b10000")
    def oneByte3 = BitPat("b11000")

    def twoByte0 = BitPat("b00010")
    def twoByte2 = BitPat("b10010")

    def allByte  = BitPat("b00100")
}

object MEMREADDECODE
{
    def oneByte0U = BitPat("b00000")
    def oneByte1U = BitPat("b01000")
    def oneByte2U = BitPat("b10000")
    def oneByte3U = BitPat("b11000")

    def oneByte0S = BitPat("b00001")
    def oneByte1S = BitPat("b01001")
    def oneByte2S = BitPat("b10001")
    def oneByte3S = BitPat("b11001")

    def twoByte0U = BitPat("b00010")
    def twoByte2U = BitPat("b10010")

    def twoByte0S = BitPat("b00011")
    def twoByte2S = BitPat("b10011")

    def allByte0  = BitPat("b00100")

}

